module Hwk2 where
import Data.Char

-- 1.
-- this function expects as input parameter list of positive numbers and
-- output is number; it is sum of list of numbers is counted
-- recursively
sum' :: (Num a) => [a] -> a
sum' [] = 0
sum' (x:xs) = x + sum' xs

-- this function expects as an input positive int
-- and output is also int; in every step counts square
-- of first member of the actual list and add whole sum of squares
-- is counted recursively
sumSquare :: Int -> Int
sumSquare 0 = 0
sumSquare n = n * n + sumSquare (n-1)

-- this function expects as an input positive int
-- and output is also int;in this example is list of squares done by the list generator
-- and then the sum is counted by the function sum' declared before
sumSquare' :: Int -> Int
sumSquare' n = sum'[x * x | x <- [1..n]]

-- 2.
-- this function expects as an input triple of positive ints
-- and output is Bool value;function controls if members of given triple
-- are sides of pythagorean triangle
isPyth :: (Int, Int, Int) -> Bool
isPyth (a, b, c) = c * c == a * a + b * b

-- this function expects as an input int and output is a list of triples;
-- in this function is triple of sides generated by the list generator
-- and it is controlled by the function isPyth if given sides are sides
-- of pythagorean triangle; for more efficiency it is also controlled if sides
-- ordinates a and b are lower than hypotenuse c and if this sides can create
-- a tringle
pyths :: Int -> [(Int, Int, Int)]
pyths n = [(a, b, c) | a <- [1..n], b <- [1..n], c <- [1..n], a < c, b < c,
    (a + b > c),isPyth (a, b, c)]

-- this function expects as an input int and output is a list of triples;
-- in this function is triple of sides generated by the list generator
-- and it is controlled by the function isPyth' in where clause if given sides are sides
-- of pythagorean triangle; for more efficiency it is also controlled if sides
-- ordinates a and b are lower than hypotenuse c and if this sides can create
-- a tringle
pyths' :: Int -> [(Int, Int, Int)]
pyths' n = [(a, b, c) | a <- [1..n], b <- [1..n], c <- [1..n], a < c, b < c,
    (a + b > c), isPyth' (a, b, c)]
    where isPyth' (a, b, c) = c * c == a * a + b * b

-- 3.
-- this function expects as an input list of ints and int and output is a list of ints;
-- function computes the 'mirror' divisors to a number when are divisors to root known
computeRestDivisors :: [Integer] -> Integer -> [Integer]
computeRestDivisors [] n = []
computeRestDivisors (x:xs) n = if ((x /= (div n x)) && (x/=1))
                                then x :((div n x) : (computeRestDivisors xs n))
                               else if (n/=x)
                                then x : (computeRestDivisors xs n)
                               else  computeRestDivisors xs n

-- this function expects as an input int and output is a list of ints;
-- this function counts by the list generator divisors of given number
-- to the root of the number and number itself is omitted
findDivisors :: Integer -> [Integer]
findDivisors num = let root = round ( sqrt (fromInteger num)) in
                computeRestDivisors [number | number <- [1..root], mod num number == 0] num

-- this function expects as an input int and output is a list of ints;
-- function generate list and adds concrete number if his sum of divisors
-- equals to number itself (uses first implementation of 'findDivisors')
perfectInt :: Integer -> [Integer]
perfectInt n = [x |x <- [1..n], sum'(findDivisors x)==x]

-- this function expects as an input int and output is a list of ints;
-- this function counts by the list generator divisors of given number
-- to the number and number itself is omitted; this is expected to be
-- a slower implementation than function 'findDivisors'
findDivisors' :: Int -> [Int]
findDivisors' n = [x |x <- [1..(n-1)], mod n x == 0]

-- this function expects as an input int and output is a list of ints;
-- function generate list and adds concrete number if his sum of divisors
-- equals to number itself; it is similar function like function 'perfectInt'
-- but for control uses second implementation of 'findDivisors''
perfectInt' :: Int -> [Int]
perfectInt' n = [x |x <- [1..n], sum'(findDivisors' x)==x]

-- 4.
-- this function expects as an input a list of characters and output is a tuple
-- where first member are numbers extracted form the list
-- and the second member is te rest; function recusrsively controls if first member
-- of actual list is number; if yes, then the member is added to the first member
-- of the tuple, if not then this member is added to the second part of the tuple;
-- the rest of the list is send recursively to the next step and in each step
-- is created a tuple and actual member is added to only a one part(first or second)
-- of the tuple; when is resulted tuple constructed, it is only taken into account
-- the member of the tuple according to his actual position (first or second)
splitString :: [Char] -> ([Char],[Char])
splitString [] = ([], [])
splitString (x:xs) = if isNumber x
                       then (x: (fst (splitString xs)),  snd (splitString xs))
                       else (fst (splitString xs),  x: (snd (splitString xs)) )


-- 5.
-- this function expects as an input a two lists of 'orderable' symbols
-- and output is ordered list of this symbols; the Ord class is used for
-- totally ordered datatypes; the Ordering datatype allows a single comparison
-- to determine the precise ordering of two objects(it is probably similar
-- like in Java implements comparable); this function is used for joining
-- two ordered lists into ordered list.
merge :: Ord a => [a] -> [a] -> [a]
merge [] [] = []
merge [] (x:[]) = [x]
merge (x:[]) [] = [x]
merge (x:[]) (y:[]) = if x <= y
                        then [x] ++ [y]
                      else
                        [y] ++ [x]
merge (x:xs) (y:[]) = if x <= y
                        then x : merge xs [y]
                      else
                        y : (x:xs)
merge (x:[]) (y:ys) = if y <= x
                        then y : merge ys [x]
                      else
                        x : (y:ys)

merge (x:xs) (y:ys) = if x <= y
                        then x : merge xs (y:ys)
                      else
                        y : merge (x:xs) ys

-- this function expects as an input a two lists of 'orderable' symbols
-- and output is ordered list of this symbols; Here is also used Ord class
-- explained before; this function firstly recursively divide input list
-- in halves and then these peices are joined and ordered by function merge
mergeSort :: Ord a => [a] -> [a]
mergeSort [] = []
mergeSort (x:[]) = [x]
mergeSort xs = merge (mergeSort (fst (splitAt (div (length xs) 2) xs)))
                 (mergeSort (snd (splitAt (div (length xs) 2) xs)))

-- 6.
--a.
-- this function expects as an input orderable symbol and list of 'orderable' symbols
-- and output is boolean value; this function only tests, if given list contains
-- input symbol
containList :: Ord a => a -> [a] -> Bool
containList x [] = False
containList x (y:ys) = if x == y
                        then True
                       else containList x ys

-- this function expects as an input two lists of 'orderable' symbols
-- and output is boolean value; this function tests if members from the first list
-- are contained in the second list; it takes one member after another and tests it;
-- when find first not contained member, then return False, otherwise when he reaches
-- empty first  list, then returns True
containElements :: Ord a => [a] -> [a] -> Bool
containElements [] ys = True
containElements (x:xs) ys = if containList x ys
                             then containElements xs ys
                            else
                                False

--b.
-- this function expects as an input two lists of 'orderable' symbols
-- and output is boolean value; this function tests if members from first
-- list are contained as a subsequence in the second list; it is controlled one after
-- another member of the first list with actual rest of the second list;
-- if function reaches end of the first list despite second list reches its end
-- or not returns True; if some members remains in the first list, then returns False;
subsequence :: Ord a => [a] -> [a] -> Bool
subsequence [] (y:ys) = True
subsequence [] []  = True
subsequence (x:xs) []  = False
subsequence (x:xs) (y:ys) = if x == y
                            then subsequence xs ys
                            else subsequence (x:xs) ys

